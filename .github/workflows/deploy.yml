name: Deploy to IIS

on:
  push:
    branches: [ master ]

jobs:
  deploy:
    runs-on: windows-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'

    - name: Publish app
      run: dotnet publish -c Release -o publish

    - name: Deploy to IIS
      # This step now explicitly stops and starts the IIS Application Pool
      # to ensure no files are locked during deployment.
      run: |
        $ErrorActionPreference = "Stop" # Ensure PowerShell stops on errors
        $appName = "data.vonet.org" # Your IIS website/application name
        $appPoolName = "data.vonet.org" # Typically the same as your site name, or check IIS Manager

        try {
          Write-Host "Stopping IIS Application Pool '$appPoolName'..."
          # Stop the application pool to release file locks
          Stop-WebAppPool -Name $appPoolName -ErrorAction Stop

          Write-Host "Starting MSDeploy deployment..."
          $msdeployArgs = @(
            "-verb:sync",
            "-source:contentPath='${{ github.workspace }}\publish'",
            "-dest:contentPath='$appName',ComputerName='${{ secrets.PUBLISH_URL }}',UserName='${{ secrets.PUBLISH_USERNAME }}',Password='${{ secrets.PUBLISH_PASSWORD }}',AuthType=Basic",
            "-allowUntrusted"
            # Removed -enableRule:AppOffline as stopping the App Pool is more robust
          )
          
          # Execute msdeploy and capture its output to temporary files
          $process = Start-Process -FilePath "C:\Program Files\IIS\Microsoft Web Deploy V3\msdeploy.exe" `
            -ArgumentList $msdeployArgs `
            -PassThru `
            -NoNewWindow `
            -Wait `
            -RedirectStandardOutput ([System.IO.Path]::GetTempFileName()) `
            -RedirectStandardError ([System.IO.Path]::GetTempFileName())
          
          # Read and display output/error streams from the temporary files
          if ($process.StandardOutput) {
            Write-Host "MSDeploy Standard Output:"
            Get-Content $process.StandardOutput | ForEach-Object { Write-Host $_ }
          }
          if ($process.StandardError) {
            Write-Error "MSDeploy Standard Error:"
            Get-Content $process.StandardError | ForEach-Object { Write-Error $_ }
          }

          # Check the exit code of msdeploy.exe
          if ($process.ExitCode -ne 0) {
            Write-Error "MSDeploy process exited with code $($process.ExitCode). Deployment failed."
            exit 1 # Fail the GitHub Actions step
          }
          Write-Host "Deployment to IIS completed successfully."

        } catch {
          Write-Error "An unexpected error occurred during deployment: $_"
          exit 1 # Fail the GitHub Actions step
        } finally {
          # Always attempt to start the application pool, even if deployment failed
          Write-Host "Attempting to start IIS Application Pool '$appPoolName'..."
          try {
            Start-WebAppPool -Name $appPoolName -ErrorAction SilentlyContinue # Use SilentlyContinue to avoid failing if already started
            Write-Host "IIS Application Pool '$appPoolName' started."
          } catch {
            Write-Warning "Could not start Application Pool '$appPoolName': $_"
          }
        }
      env:
        PUBLISH_URL: ${{ secrets.PUBLISH_URL }}
        PUBLISH_USERNAME: ${{ secrets.PUBLISH_USERNAME }}
        PUBLISH_PASSWORD: ${{ secrets.PUBLISH_PASSWORD }}
